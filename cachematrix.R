## `makeCacheMatrix` creates a  "matrix" object
## that can cache its inverse and generates a list of 
## functions, sort of class methods, that set the matrix object, get the
## object, set the inverse of the matrix (actually 
## take a value generated outside the function by cacheSolve()) and get
## the inverse of the matrix.

makeCacheMatrix <- function(x = matrix()) {
  # initializes m as cache value 
    m <- NULL
  # implements the function set(y). The argument y is a matrix
    set <- function(y) {
      x <<- y
      m <<- NULL
  # x and m are now "global" variables and can be
  # used by other functions
    }
  # implements the function get() 
    get <- function() x
  
  # implements the function setinverse(y) that assign a value
  # to the global variable `m`, whatever it should be. If the argument will be 
  # generated by `cacheSolve` it the matrix inverse of `x`
  # 
    setinverse <- function(inv) m <<- inv
  # implements the function getinverse() 
    getinverse <- function() m
  # and now return a list with all the functions
    list(set = set, get = get,
         setinverse = setinverse,
         getinverse = getinverse)
}


## This function computes the inverse of the "matrix" calculated
## by `makeCacheMatrix` above. If the inverse has
## already been calculated (and the matrix has not changed), then
## `cacheSolve` retrieves the inverse from the cache.

cacheSolve <- function(x, ...) {
    # retrieves the inverse from the cache created by 
    # `makeCacheMatrix`
    m <- x$getinverse()
    if(!is.null(m)) {
      message("getting cached data")
      # if there is a value in the cache it is returned and the
      # function is interrupted
      return(m)
    }
    # if the cache is empty calculate the inverse
    data <- x$get()
    m <- solve(data, ...)
    # and is saved inside the cache
    x$setinverse(m)
    ## Return a matrix that is the inverse of 'x'
    m
}
